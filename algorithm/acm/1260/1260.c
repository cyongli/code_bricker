 /*
  给出几类珍珠，以及它们的单价，要求用最少的钱就可以买到相同数量的，相同（或更高）质量的珍珠。
  [规定买任一类的珍珠n个(价格为p)，都要支付(n+10)*p的钱]
 
  例如样例Input的第二个例子：
  3
  1 10
  1 11
  100 12
  需要买第一类1个，第二类1个，第三类100个
  按常规支付为 (1+10)*10 + (1+10)*11 + (100+10)*12 = 1551元（一共买了102个珍珠）
  但是如果全部都按照第三类珍珠的价格支付，同样是买102个，而且其中总体质量还被提高了，
  但是价格却下降了：(102+10)*12 = 1344元
 
  而对于样例Input的第一个例子：
  2  
  100 1
  100 2
  按常规支付为 （100+10）*1 + (100+10)*2 =330元
  但是全部按第二类珍珠的价格支付，同样买200个，虽然总体质量提升了，但是价格也提高了： (202+10)*2=424元
  
  本题关键点在于：
  (1) 要求要买的珍珠的数量是一定的
  (2) 所买的珍珠的质量允许提高，但不允许下降（即可以用高质量珍珠替代低质量）
  (3) 输入时，后输入的珍珠价格一定比前面输入的要贵
  (4) 由(2)(3)知，珍珠的替代必须是连续的，不能跳跃替代（这个不难证明，因为假如用第i+2类去替代第i类珍珠，
      会使最终的支付价格降低，那么用第i+1类去替代第i类珍珠会使最终的支付价格更加低）
 
  根据这4个约束条件，那么购买珍珠的方案为:
    在珍珠类型的总区间[1,c]中划分多个子区间，其中在闭区间i1~j1的珍珠全部按第j1类珍珠的价格p1支付，
    在闭区间i2~j2的珍珠全部按第j2类珍珠的价格p2支付
    ......   
    在闭区间in~jn的珍珠全部按第jn类珍珠的价格pn支付。
    这些区间互不相交。其余珍珠按其原价支付。
    要求找出最优的划分方案，使得最终支付价格最低。
    
    令dp[i]表示在已知第i类珍珠时,所需支付的最低价格
    则状态方程为：
    dp[i]=(a[i]+10)*p[i]+dp[i-1];  //当第i种珍珠出现时，未优化价格的情况
    dp[i]=min(dp[i],(sum[i]-sum[j]+10)*p[i]+dp[j]);  //枚举j，价格优化
    dp[0]=0;
*/

#include<stdio.h>
#include<string.h>

int n,c;
int ai[101];
int pi[101];
int dp[101];
int sum[101];

static inline int min(int x,int y){
  return (x<y)?x:y;
}

int main(){
  int i,j,k;
  scanf("%d",&n);
  for(k=1;k<=n;k++){
    memset(ai,0,sizeof(ai));
    memset(pi,0,sizeof(pi));
    memset(dp,0,sizeof(dp));
    memset(sum,0,sizeof(sum));
    scanf("%d",&c);
    for(i=1;i<=c;i++){
      scanf("%d %d",&(ai[i]),&(pi[i]));
      sum[i] = sum[i-1]+ai[i];
    }
    for(i=1;i<=c;i++){
      dp[i]=(ai[i]+10)*pi[i]+dp[i-1];
      for(j=i-1;j>=0;j--)
        dp[i] = min(dp[i],(sum[i]-sum[j]+10)*pi[i]+dp[j]);
    }
    printf("%d\n",dp[c]);
  } 
  return 0;
}
